# Lab2: Memory Management
[guide link](https://pdos.csail.mit.edu/6.828/2018/labs/lab2/)
## Introduction
Writing memory management code for our OS, memory management have two components:
1. physical memory allocator for kernel, so that the kernel can allocate memory and later free it.
2. virtual memory, which maps the virtual address used by kernel and user software to address in physical memory.

## Getting started
```sh
cd lab 
git checkout -b lab2 origin/lab2
```
## Part 1: Physical Page Management

JOS manages the PC's physical memory with `page` granularity, and use the MMU to map and protect each piece of allocated memory.

Let's review this booting process. OS loads the bootsector to 0x7c00 first sets the environment, then call to bootmain in c code. bootmain loads the kernel and call into kernel entry. Kernel loads entry_pgdir to cr3 to enable Paging, then call `i386_init`. i386_init Clear the BSS, call `cons_init()` to set up the screen display device and making it ready for cprintf to run, then call `mem_init()`. Finally call `monitor()` to interact with users.

Before calling to i386_int(), the memory distribution is shown in the figure below:

![](../images/1.jpg)

Now need to write **physical page allocator**, which keeps track of which pages are free with a linked list of `struct Pageinfo` objects(`memlayout.h` line 175). A object corresponding to a physical page.

### Exercise 1
In the file `kern/pmap.c`, you must implement code for the following functions (probably in the order given).
> 
> boot_alloc()
> 
> mem_init() (only up to the call to check_page_free_list(1))
> 
> page_init()
> 
> page_alloc()
> 
> page_free()
> 
> check_page_free_list() and check_page_alloc() test your physical page allocator. 

pages结构体数组是用于映射所有内存空间的，page_free_list指针指向的结构体所映射的内存空间均可用。page_alloc函数将从 pages 数组空间中分配可用空间，结构体映射的物理页地址将作为线性地址的页表，将其存储到页目录里。

**boot_alloc()**

boot_alloc() use a magic symbol `end` to get BSS tail which pointe to first free memory.

`ROUNDUP(n, M)` returns a num that satisfy `num % M == 0 && M >= num >= n`

```c
boot_alloc(uint32_t n)
{
	static char *nextfree;	// virtual address of next byte of free memory
	char *result;

	// Initialize nextfree if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker did *not* assign
	// to any kernel code or global variables.
	if (!nextfree) {
		extern char end[];
		nextfree = ROUNDUP((char *) end, PGSIZE);	// round end up to PGSIZE
	}

	// Allocate a chunk large enough to hold 'n' bytes, then update
	// nextfree.  Make sure nextfree is kept aligned
	// to a multiple of PGSIZE.
	//
	// LAB 2: Your code here.
	if(n == 0)
		return nextfree;		// if n == 0, return nextfree, not allocate any memory.
	result = nextfree;
	nextfree += ROUNDUP(n, PGSIZE);		// align to PGSIZE
	return result;
}
```

**mem_init()**

Need to use `PageInfo` in `/inc/memlayout.h`


```c
struct PageInfo {
	// Next page on the free list.
	struct PageInfo *pp_link;

	// pp_ref is the count of pointers (usually in page table entries)
	// to this page, for pages allocated using page_alloc.
	// Pages allocated at boot time using pmap.c's
	// boot_alloc do not have valid reference count fields.

	uint16_t pp_ref;
};
```

code as discribe:

```c
//////////////////////////////////////////////////////////////////////
	// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
	// The kernel uses this array to keep track of physical pages: for
	// each physical page, there is a corresponding struct PageInfo in this
	// array.  'npages' is the number of physical pages in memory.  Use memset
	// to initialize all fields of each struct PageInfo to 0.
	// Your code goes here:
	pages = (struct PageInfo*) boot_alloc(npages * sizeof(struct PageInfo));
	memset(pages, 0, npages * sizeof(struct PageInfo));
```

**page_init()**

```c
void
page_init(void)
{
	// The example code here marks all physical pages as free.
	// However this is not truly the case.  What memory is free?

	//  1) Mark physical page 0 as in use.
	//     This way we preserve the real-mode IDT and BIOS structures
	//     in case we ever need them.  (Currently we don't, but...)
	pages[0].pp_ref = 1;
	//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)
	//     is free.
	size_t i;
	for (i = 1; i < npages_basemem; i++) {
		pages[i].pp_ref = 0;
		pages[i].pp_link = page_free_list;
		page_free_list = &pages[i];
	}
	//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must
	//     never be allocated.
	for(i = IOPHYSMEM/PGSIZE, i < EXTPHYSMEM/PGSIZE, i++) {
		pages[i].pp_ref = 1;
	}
	//  4) Then extended memory [EXTPHYSMEM, ...).
	//     Some of it is in use, some is free. Where is the kernel
	//     in physical memory?  Which pages are already in use for
	//     page tables and other data structures?
	size_t first_free = PADDR(boot_alloc(0));
	for(i = EXTPHYSMEM/PGSIZE, i < first_free/PGSIZE, i++) {
		pages[i].pp_ref = 1;
	}
	for(i = first_free/PGSIZE; i < npages, i++) {
		pages[i].pp_ref = 0;
		pages[i].pp_link = page_free_list;
		page_free_list = &pages[i];
	}
	//
	// Change the code to reflect this.
	// NB: DO NOT actually touch the physical memory corresponding to
	// free pages!
}
```

**page_alloc()**

```c
struct PageInfo *
page_alloc(int alloc_flags)
{
	// Fill this function in
	if(page_free_list == NULL) {
		return NULL;
	}
	
	struct PageInfo* allocated_page = page_free_list;
	page_free_list = page_free_list->pp_link;

	allocated_page->pp_link = NULL;

	if(alloc_flags & ALLOC_ZERO) {
		memset(page2kva(allocated_page), '/0', PGSIZE);
	}

	return allocated_page;
}
```

**page_free()**

```c
void
page_free(struct PageInfo *pp)
{
	// Fill this function in
	// Hint: You may want to panic if pp->pp_ref is nonzero or
	// pp->pp_link is not NULL.
	if(pp->pp_ref != 0 || pp->pp_link != NULL) {
		panic("Double check failed when free page");
		return;
	}

	pp->pp_link = page_free_list;
	page_free_list = &pp;
}
```

## Part2: Virtual Memory

### Exercise2 familiarize  x86's protected-mode memory management architecture
Look at chapters 5 and 6 of the Intel 80386 Reference Manual.


![](../images/sd.png)

detail in [Intel 80386 Reference Manual](https://pdos.csail.mit.edu/6.828/2018/readings/i386/toc.htm)

### Virtual, Linear, and Physical Addresses

```

           Selector  +--------------+         +-----------+
          ---------->|              |         |           |
                     | Segmentation |         |  Paging   |
Software             |              |-------->|           |---------->  RAM
            Offset   |  Mechanism   |         | Mechanism |
          ---------->|              |         |           |
                     +--------------+         +-----------+
            Virtual                   Linear                Physical
```

In `boot/boot.S`, we installed a Global Descriptor Table (GDT) that effectively **disabled segment translation** by setting all segment base addresses to 0 and limits to 0xffffffff. Hence the `"selector"` has no effect and the linear address always equals the offset of the virtual address. JOS focus solely on oage translation.

the JOS source distinguishes the two cases: the type `uintptr_t` represents opaque virtual addresses, and `physaddr_t` represents physical addresses. But both are `uint32_t`.

### Exercise4
In the file `kern/pmap.c`, you must implement code for the following functions.
```c
pgdir_walk()
boot_map_region()
page_lookup()
page_remove()
page_insert()
```
`check_page()`, called from `mem_init()`, tests your page table management routines. You should make sure it reports success before proceeding.

**pgdir_walk()**

`pgdir_walk()`函数根据线性地址返回二级页表项入口。首先获取页目录项位置，使用指针指向其索引位置。如果页目录项不存在二级页表映射，且create标识为0，则返回NULL。否则使用page_alloc函数分配页表空间，分配失败则返回NULL，否则将分配的PageInfo结构体引用加1，并将其对应的物理页地址和权限（二级页表权限设为 kern R/W, user R/W）存在页目录项中。二级页表物理地址是4K对齐的，将其低12位清零然后转化为内核地址，使用指针指向它。注意到页目录和页表存的是物理地址，而指向页目录和页表的指针需要使用逻辑地址。最后根据指向二级页表的指针和通过线性地址求得的二级页表项索引，返回指向二级页表项的指针。

Given 'pgdir', a pointer to a page directory, pgdir_walk returns a pointer to the page table entry (PTE) for linear address 'va'.

pgdir_walk()只负责创建二级页表，然后返回指向二级页表项的指针，不对二级页表做处理，也不做其对物理页映射。

```c
pte_t *
pgdir_walk(pde_t *pgdir, const void *va, int create)
{
	// Fill this function in
	uint32_t page_dir_index = PDX(va);
	uint32_t page_tab_index = PTX(va);
	pte_t* PTT;
	if(pgdir[page_dir_index] & PTE_P) {
		PTT = KADDR(PTE_ADDR(pgdir[page_dir_index]));
	}
	else {
		if(create) {
			struct PageInfo* new_pi = page_alloc(ALLOC_ZERO);
			if(new_pi) {
				new_pi->pp_ref += 1;
				PTT = (pte_t*)page2kva(new_pi);
				// PAGESIZE align, later 12bit 0
				pgdir[page_dir_index] = PADDR(PTT) | PTE_P | PTE_W | PTE_U;
			}
			else {
				return NULL;
			}
		}
		else {
			return NULL;
		}
	}
	return &PTT[page_tab_index];	// return PTE
}
```

**page_lookup()**

`page_lookup()`函数根据线性地址返回二级页表项所指的物理页对应的PageInfo数据结构。

`page_lookup()`函数调用`pgdir_walk()`获得指向二级页表项的指针，不允许创建二级页表。如果页目录项不存在二级页表映射且不允许创建二级页表，或者没有空间分配二级页表，`pgdir_walk()`会返回NULL，则page_lookup()返回NULL。如果获得的二级页表项不存在物理页映射，则`page_lookup()`返回NULL。否则将二级页表项的地址存于`pte_t **pte_store`，`pgdir_walk()`返回的二级页表项指针内容是所指的物理页物理地址，将其低12位清零，并返回对应的`PageInfo`数据结构。

```c
struct PageInfo *
page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)
{
	// pte_t **pte_store 存储的是二级页表项的地址
	// Fill this function in
	pte_t* pte = pgdir_walk(pgdir, va, 0);
	if(pte == NULL) {
		return NULL;
	}
	if(pte_store) {
		*pte_store = pte;
	}
	return pa2page(PTE_ADDR(*pte));	// return PageInfo struct
}
```

**page_remove()**

page_remove()函数移除线性地址对应的物理页，清空二级页表项，使tlb无效化。

page_remove()函数通过调用page_lookup()函数获得线性地址对应的物理页的PageInfo数据结构，然后调用page_decref()函数将PageInfo对象引用减1，如果引用为0则释放该内存页。

```c
void
page_remove(pde_t *pgdir, void *va)
{
	// Fill this function in
	pte_t* PTT;
	pte_t** pte_store = &PTT;
	struct PageInfo* pi = page_lookup(pgdir, va, pte_store);
	if(!pi) {
		return;
	}
	page_decref(pi);
	*PTT = 0;
	tlb_invalidate(pgdir, va);
}
```

**page_insert()**

`page_insert()`函数将映射物理页的`PageInfo`数据结构`pp`的地址及访问权限存于线性地址`va`所对应的二级页表项内。

`page_insert()`函数首先调用`pgdir_walk()`函数获得指向线性地址的二级页表项的指针，允许创建二级页表。当对应的二级页表不存在且没有足够内存空间创建二级页表时，`pgdir_walk()`函数返回NULL，则`page_insert()`函数返回-1。

否则`pgdir_walk()`函数返回指向二级页表项的指针，当该指针的P存在位为1时，代表当前二级页表项存在物理页映射，这时候需要判断该物理页与要插入的物理页是否是同一页，判断方法是：将指针内容（已经是物理地址）低12位清零，与函数参数`PageInfo *pp`转化为`PageInfo`的指针进行比较。
- 如果是同一页，应该允许修改权限（包括降低权限，所以先清空低12位）后直接返回0，
- 否则调用page_remove()函数移除线性地址对应的物理页，清空二级页表项。

接着待插入的PageInfo指针pp的引用加1，将pp对应的物理页物理地址及权限存于二级页表项处，使tlb无效化。



```c
int
page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)
{
	// Fill this function in
	pte_t* pte = pgdir_walk(pgdir, va, 1);	// Get pte of va, if not, establish one 
	if(pte == NULL) {		// allocate failed, no space
		return -E_NO_MEM;
	}

	// try not to distinguish same page situation
	//if(*pte & PTE_P) {	// if page have existed and Present
	//	if(pa2page(pp) == PTE_ADDR(pte)) {	// same page?
	//		*pte = page2pa(pp) | perm | PTE_P;
	//		return 0;
	//	}
	//	else {
	//		page_remove(pgdir, va);
	//	}
	//}

	//注意如果已映射的物理页和待插入的物理页是同一页的话，不能先移除物理页p再将pp的引用加1，
	//因为一旦移除物理页pte，p可能因为引用为0而被释放，
	//进而page_free_list指向这块内存页，将其标记为可用，而此时pp的物理页是不可用的。
	pp->pp_ref ++;
	if(*pte & PTE_P) {
		page_remove(pgdir, va);
	}
	*pte = page2pa(pp) | perm | PTE_P;
	tlb_invalidate(pgdir, va);
	return 0;
}
```


**boot_map_region()**

boot_map_region()函数将线性地址空间[va, va+size)映射到物理地址空间[pa, pa+size)。pa、va是页对齐的，size是页大小的倍数。

boot_map_region()函数循环调用pgdir_walk()函数返回指向二级页表项的指针，然后将对应的物理地址和权限存储到该指针。